#!/usr/bin/env python3
"""
AI-Powered PDF Form Filler v3 - FIXED VERSION
Author: Assistant
Description: A PyQt6 GUI application for filling any fillable PDF form with AI-powered data extraction
"""

import sys
import json
import subprocess
import tempfile
import os
import re
import base64
import logging
import traceback
import dotenv
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union, Any
from dataclasses import dataclass, asdict

# Set up logging
logging.basicConfig(
    filename='pdf_form_filler_debug.log',
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('PDF_Form_Filler')
logger.info("Application starting")

from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QVBoxLayout, QHBoxLayout, QWidget,
    QPushButton, QFileDialog, QTableWidget, QTableWidgetItem,
    QLabel, QLineEdit, QTextEdit, QSplitter, QTabWidget,
    QMessageBox, QProgressBar, QGroupBox, QScrollArea,
    QGridLayout, QComboBox, QSpinBox, QCheckBox, QListWidget,
    QListWidgetItem, QPlainTextEdit, QFrame, QSizePolicy, QRadioButton,
    QInputDialog
)
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QSettings, QTimer
from PyQt6.QtGui import QFont, QIcon, QPalette, QColor, QPixmap

# Import field mapping widget
try:
    from fieldmappingwidget import FieldMappingWidget, FormField
    FIELD_MAPPING_AVAILABLE = True
except ImportError:
    FIELD_MAPPING_AVAILABLE = False
    print("⚠️ FieldMappingWidget not available - creating placeholder")
    
    # Create placeholder classes
    @dataclass
    class FormField:
        name: str
        field_type: str = "Text"
        alt_text: str = ""
        flags: int = 0
        justification: str = "Left"
        state_options: List[str] = None
        
        def __post_init__(self):
            if self.state_options is None:
                self.state_options = []
    
    class FieldMappingWidget(QWidget):
        def __init__(self):
            super().__init__()
            self.fields = []
            self.init_ui()
        
        def init_ui(self):
            layout = QVBoxLayout()
            layout.addWidget(QLabel("Field Mapping Widget (Placeholder)"))
            self.setLayout(layout)
        
        def set_fields(self, fields):
            self.fields = fields
        
        def get_field_data(self):
            return {}
        
        def set_field_data(self, data):
            pass

# AI/ML Imports with error handling
try:
    import openai
    OPENAI_AVAILABLE = True
    print("✅ OpenAI library available")
except ImportError:
    OPENAI_AVAILABLE = False
    print("⚠️ OpenAI library not available")

try:
    import anthropic
    ANTHROPIC_AVAILABLE = True
    print("✅ Anthropic library available")
except ImportError:
    ANTHROPIC_AVAILABLE = False
    print("⚠️ Anthropic library not available")

# Optional imports
try:
    from PIL import Image
    import pytesseract
    OCR_AVAILABLE = True
except ImportError:
    OCR_AVAILABLE = False

try:
    import requests
    from bs4 import BeautifulSoup
    WEB_SCRAPING_AVAILABLE = True
except ImportError:
    WEB_SCRAPING_AVAILABLE = False

try:
    import PyPDF2
    import pdfplumber
    PDF_TEXT_AVAILABLE = True
except ImportError:
    PDF_TEXT_AVAILABLE = False

@dataclass
class DataSource:
    """Represents a data source for AI extraction"""
    name: str
    source_type: str  # 'file', 'text', 'url', 'image'
    content: str
    extracted_data: Dict[str, Any] = None
    confidence_scores: Dict[str, float] = None

    def __post_init__(self):
        if self.extracted_data is None:
            self.extracted_data = {}
        if self.confidence_scores is None:
            self.confidence_scores = {}

class AIDataExtractor(QThread):
    """Thread for AI-powered data extraction from various sources"""
    data_extracted = pyqtSignal(dict, dict)  # extracted_data, confidence_scores
    error_occurred = pyqtSignal(str)
    progress_updated = pyqtSignal(int, str)  # progress, status_message
    show_message = pyqtSignal(str, str)  # title, message for safe UI thread display

    def __init__(self, sources: List[DataSource], form_fields: List[FormField],
                 ai_provider: str = "openai", api_key: str = "", model: str = ""):
        super().__init__()
        self.sources = sources
        self.form_fields = form_fields
        self.ai_provider = ai_provider
        self.api_key = api_key
        self.model = model

    def run(self):
        try:
            logger.info("AIDataExtractor: Starting extraction...")
            print("AIDataExtractor: Starting extraction...")
            self.progress_updated.emit(10, "Initializing AI extraction...")
            
            # Extract text from all sources
            all_text = ""
            extracted_data = {}
            confidence_scores = {}
            
            logger.info(f"AIDataExtractor: Processing {len(self.sources)} sources with provider {self.ai_provider}")
            print(f"AIDataExtractor: Processing {len(self.sources)} sources with provider {self.ai_provider}")
            
            for i, source in enumerate(self.sources):
                progress = 20 + (i * 30 // max(len(self.sources), 1))
                self.progress_updated.emit(progress, f"Processing {source.name}...")
                print(f"AIDataExtractor: Processing source {i+1}/{len(self.sources)}: {source.name} (type: {source.source_type})")
                
                if source.source_type == "file":
                    text = self._extract_from_file(source.content)
                elif source.source_type == "image":
                    text = self._extract_from_image(source.content)
                elif source.source_type == "url":
                    text = self._extract_from_url(source.content)
                else:
                    text = source.content
                
                print(f"AIDataExtractor: Extracted {len(text)} characters from {source.name}")
                all_text += f"\n\n=== {source.name} ===\n{text}"
            
            self.progress_updated.emit(60, "Running AI analysis...")
            
            # Use AI to extract structured data
            print(f"AIDataExtractor: Using AI provider: {self.ai_provider}")
            print(f"AIDataExtractor: OpenAI available: {OPENAI_AVAILABLE}")
            print(f"AIDataExtractor: Anthropic available: {ANTHROPIC_AVAILABLE}")
            print(f"AIDataExtractor: Has API key: {'Yes' if self.api_key else 'No'}")
            
            if self.ai_provider == "openai" and OPENAI_AVAILABLE:
                print("AIDataExtractor: Using OpenAI for extraction")
                extracted_data, confidence_scores = self._extract_with_openai(all_text)
            elif self.ai_provider == "anthropic" and ANTHROPIC_AVAILABLE:
                print("AIDataExtractor: Using Anthropic for extraction")
                extracted_data, confidence_scores = self._extract_with_anthropic(all_text)
            else:
                print("AIDataExtractor: Using pattern matching for extraction")
                extracted_data, confidence_scores = self._extract_with_patterns(all_text)
            
            print(f"AIDataExtractor: Extraction complete. Found {len(extracted_data)} fields")
            self.progress_updated.emit(100, "AI extraction complete")
            self.data_extracted.emit(extracted_data, confidence_scores)
            
        except Exception as e:
            import traceback
            error_msg = f"AI extraction error: {str(e)}"
            logger.error(error_msg)
            logger.error(traceback.format_exc())
            print(f"AIDataExtractor ERROR: {str(e)}")
            print(traceback.format_exc())
            self.error_occurred.emit(error_msg)

    def _extract_from_file(self, file_path: str) -> str:
        """Extract text from various file types"""
        try:
            file_path = Path(file_path)
            
            if file_path.suffix.lower() == '.pdf':
                print(f"DEBUG: PDF file detected: {file_path.name}")
                return f"[PDF FILE: {file_path.name}] This is a PDF form that should be processed directly by the AI model."
            
            elif file_path.suffix.lower() in ['.txt', '.md', '.csv']:
                with open(file_path, 'r', encoding='utf-8') as file:
                    return file.read()
            
            elif file_path.suffix.lower() in ['.json']:
                with open(file_path, 'r', encoding='utf-8') as file:
                    data = json.load(file)
                    return json.dumps(data, indent=2)
            
            else:
                return f"Unsupported file type: {file_path.suffix}"
                
        except Exception as e:
            print(f"ERROR reading file {file_path}: {str(e)}")
            return f"Error reading file: {str(e)}"

    def _extract_from_image(self, image_path: str) -> str:
        """Extract text from images using OCR"""
        if not OCR_AVAILABLE:
            return "OCR not available. Install pytesseract and Pillow."
        
        try:
            image = Image.open(image_path)
            text = pytesseract.image_to_string(image)
            return text
        except Exception as e:
            return f"OCR error: {str(e)}"

    def _extract_from_url(self, url: str) -> str:
        """Extract text from web pages"""
        if not WEB_SCRAPING_AVAILABLE:
            return "Web scraping not available. Install requests and beautifulsoup4."
        
        try:
            response = requests.get(url, timeout=30)
            response.raise_for_status()
            soup = BeautifulSoup(response.content, 'html.parser')
            
            # Remove script and style elements
            for script in soup(["script", "style"]):
                script.decompose()
            
            text = soup.get_text()
            lines = (line.strip() for line in text.splitlines())
            chunks = (phrase.strip() for line in lines for phrase in line.split("  "))
            text = ' '.join(chunk for chunk in chunks if chunk)
            
            return text
        except Exception as e:
            return f"Web scraping error: {str(e)}"

    def _extract_with_openai(self, text: str) -> Tuple[Dict[str, str], Dict[str, float]]:
        """Extract data using OpenAI GPT"""
        if not self.api_key:
            raise ValueError("OpenAI API key required")
        
        print("="*50)
        print("OPENAI EXTRACTION DEBUGGING")
        print(f"API Key length: {len(self.api_key)} chars")
        print(f"Model specified: {self.model}")
        print(f"Text length for analysis: {len(text)} chars")
        
        # Create field extraction prompt
        field_names = [f.name for f in self.form_fields]
        field_descriptions = [f.alt_text or f.name for f in self.form_fields]
        
        print(f"Number of fields to extract: {len(field_names)}")
        if field_names:
            print(f"First field: {field_names[0]}")
        
        prompt = f"""# Legal Document Data Extraction Task

You are extracting data from California family law documents to fill an FL-142 Schedule of Assets and Debts form.

## SOURCE DOCUMENTS:
You are analyzing PDF documents that contain filled-in legal forms.

## TARGET: FL-142 Form Fields  
Extract data for these specific fields (use EXACT field names as keys):

{json.dumps(dict(zip(field_names, field_descriptions)), indent=2)}

## EXTRACTION STRATEGY:

### 1. ATTORNEY INFORMATION (from FL-120 if present):
- Attorney Name: Look for attorney signature, "Attorney for [Party]", or professional contact info
- Attorney Phone: Phone numbers in attorney contact section  
- Attorney Email: Email addresses in attorney contact section
- Attorney Address: Professional address for attorney

### 2. CASE INFORMATION (from any source):
- Case Number: Format like "24STFL00615"
- Petitioner: First named party (often "PETITIONER:")  
- Respondent: Second named party (often "RESPONDENT:")
- Court County: Look for court jurisdiction like "LOS ANGELES"

### 3. FINANCIAL DATA (from FL-142 if present):
Look for FILLED-IN dollar amounts (ignore $0.00 entries):
- Student Loans: Education debt amounts
- Unsecured Loans: Personal loans, lines of credit
- Credit Cards: Credit card balances and debts  
- Other Debts: Additional liabilities
- Total Debts: Sum of all debts
- Assets: Bank accounts, real estate, vehicles

## CRITICAL RULES:

✅ **USE EXACT FIELD NAMES** - Return the exact field name from the list above as the key
✅ **EXTRACT ACTUAL DATA ONLY** - filled-in values, not blank fields or form labels
✅ **IGNORE TEMPLATE TEXT** - Skip instructions like "Give details", "Attach copy"
✅ **LOOK FOR REAL VALUES** - Names, dollar amounts, case numbers, contact info
✅ **CROSS-REFERENCE DOCUMENTS** - Use attorney info from FL-120 for attorney fields

## DOCUMENT CONTENT TO ANALYZE:
{text[:6000]}

Extract all relevant data and return in this exact JSON format:

{{
    "extracted_data": {{
        "EXACT_FIELD_NAME": "extracted_value"
    }},
    "confidence_scores": {{
        "EXACT_FIELD_NAME": 0.95
    }}
}}

Focus on quality over quantity - extract what you can clearly identify."""
        
        try:
            # Try to use llm_client if available
            try:
                import llm_client
                os.environ["OPENAI_API_KEY"] = self.api_key.strip()
                print(f"Set OPENAI_API_KEY environment variable")
                
                openai_model = self.model.replace("openai-", "") if self.model else "gpt-3.5-turbo"
                print(f"Calling llm_client.generate_with_openai with model: {openai_model}")
                
                response_text = llm_client.generate_with_openai(openai_model, prompt)
                print(f"OpenAI response received, length: {len(response_text)}")
                
            except ImportError:
                # Fallback to direct OpenAI API
                print("llm_client not available, using direct OpenAI API")
                openai.api_key = self.api_key
                
                response = openai.ChatCompletion.create(
                    model=self.model or "gpt-3.5-turbo",
                    messages=[{"role": "user", "content": prompt}],
                    temperature=0.1
                )
                response_text = response.choices[0].message.content
            
            # Parse the JSON response
            start = response_text.find('{')
            end = response_text.rfind('}') + 1
            
            if start >= 0 and end > start:
                json_text = response_text[start:end]
                try:
                    result = json.loads(json_text)
                    extracted_data = result.get("extracted_data", {})
                    confidence_scores = result.get("confidence_scores", {})
                    print(f"Successfully parsed JSON with {len(extracted_data)} extracted fields")
                    return extracted_data, confidence_scores
                except json.JSONDecodeError as e:
                    print(f"JSON decode error: {e}")
                    return {}, {}
            else:
                print(f"Invalid JSON response from OpenAI")
                return {}, {}
            
        except Exception as e:
            print(f"OpenAI API error: {str(e)}")
            self.show_message.emit("OpenAI API Error", f"Error: {str(e)}")
            return {}, {}

    def _extract_with_anthropic(self, text: str) -> Tuple[Dict[str, str], Dict[str, float]]:
        """Extract data using Anthropic Claude"""
        if not self.api_key:
            raise ValueError("Anthropic API key required")

        print("="*50)
        print("CLAUDE EXTRACTION DEBUGGING")
        print(f"API Key length: {len(self.api_key)} chars")
        print(f"Model specified: {self.model}")
        print(f"Text length for analysis: {len(text)} chars")

        try:
            field_names = [f.name for f in self.form_fields]
            field_descriptions = [f.alt_text or f.name for f in self.form_fields]

            print(f"Number of fields to extract: {len(field_names)}")
            if field_names:
                print(f"First field: {field_names[0]}")

            # Use the model specified by the user, or fall back to a default
            model = self.model if self.model else "claude-3-sonnet-20240229"
            print(f"Using Claude model: {model}")

            # Generic prompt for any form type
            prompt = f"""You are analyzing documents to extract comprehensive data for a PDF form.

EXTRACTION TARGET: Extract data for ALL available fields.

COMPREHENSIVE EXTRACTION STRATEGY:
- Extract data from ALL source documents
- Match data to the appropriate field locations  
- Be comprehensive - try to fill as many fields as possible

EXTRACTION RULES:
✅ **USE EXACT FIELD NAMES**: Return the exact field name from the list as the key
✅ **BE COMPREHENSIVE**: Try to extract data for as many fields as possible
✅ **EXTRACT FROM ALL SOURCES**: Look in ALL source documents
✅ **EXTRACT REAL VALUES**: Only filled-in data, ignore blank fields

TARGET FIELDS:
{json.dumps(dict(zip(field_names, field_descriptions)), indent=2)}

DOCUMENT CONTENT TO ANALYZE:
{text[:4000]}

RETURN FORMAT:

{{
    "extracted_data": {{
        "EXACT_FIELD_NAME": "extracted_value"
    }},
    "confidence_scores": {{
        "EXACT_FIELD_NAME": 0.95
    }}
}}

Extract data for AS MANY fields as possible."""

            try:
                # Try to use llm_client if available
                import llm_client
                os.environ["ANTHROPIC_API_KEY"] = self.api_key.strip()
                print(f"Set ANTHROPIC_API_KEY environment variable")
                
                response_text = llm_client.generate_with_claude(model, prompt)
                print(f"Claude response received, length: {len(response_text)}")
                
            except ImportError:
                # Fallback to direct Anthropic API
                print("llm_client not available, using direct Anthropic API")
                client = anthropic.Anthropic(api_key=self.api_key)
                
                response = client.messages.create(
                    model=model,
                    max_tokens=1000,
                    messages=[{"role": "user", "content": prompt}]
                )
                response_text = response.content[0].text

            # Parse response
            start = response_text.find('{')
            end = response_text.rfind('}') + 1

            if start >= 0 and end > start:
                json_text = response_text[start:end]
                try:
                    result = json.loads(json_text)
                    extracted_data = result.get("extracted_data", {})
                    confidence_scores = result.get("confidence_scores", {})

                    # If missing confidence scores, generate defaults
                    if not confidence_scores and extracted_data:
                        confidence_scores = {k: 0.85 for k in extracted_data.keys()}

                    print(f"Successfully parsed JSON with {len(extracted_data)} extracted fields")
                    return extracted_data, confidence_scores

                except json.JSONDecodeError as e:
                    print(f"JSON decode error: {e}")
                    return {}, {}
            else:
                print(f"Invalid JSON response from Claude")
                return {}, {}

        except Exception as e:
            print(f"Claude API error: {str(e)}")
            self.show_message.emit("Claude API Error", f"Error: {str(e)}")
            return {}, {}

    def _extract_with_patterns(self, text: str) -> Tuple[Dict[str, str], Dict[str, float]]:
        """Pattern-based extraction fallback"""
        print("🔍 Using pattern matching extraction")
        
        extracted_data = {}
        confidence_scores = {}
        
        # Enhanced patterns for key legal form data
        patterns = {
            # People and roles
            'attorney_name': r'attorney.*?([A-Z][a-z]+ [A-Z][a-z]+)',
            'petitioner_name': r'petitioner.*?([A-Z][a-z]+ [A-Z][a-z]+)',
            'respondent_name': r'respondent.*?([A-Z][a-z]+ [A-Z][a-z]+)',
            
            # Case information
            'case_number': r'case.*?number.*?([A-Z0-9]+)',
            'court_county': r'county of\s+([A-Z\s]+)',
            
            # Financial amounts
            'student_loan': r'student.*?loan.*?\$?\s*([0-9,]+\.?[0-9]*)',
            'credit_card': r'credit.*?card.*?\$?\s*([0-9,]+\.?[0-9]*)',
            'total_debt': r'total.*?debt.*?\$?\s*([0-9,]+\.?[0-9]*)',
            
            # Contact info
            'phone': r'\((\d{3})\)\s*(\d{3})-(\d{4})',
            'address': r'(\d+\s+[A-Za-z\s]+(Street|St|Avenue|Ave|Road|Rd|Drive|Dr))',
        }
        
        # Extract using patterns
        for field in self.form_fields:
            field_name = field.name
            field_text = (field.name + " " + (field.alt_text or "")).lower()
            
            best_value = None
            best_confidence = 0
            
            # Try to match field intent with patterns
            for pattern_type, pattern in patterns.items():
                if any(word in field_text for word in pattern_type.split('_')):
                    matches = re.finditer(pattern, text, re.IGNORECASE)
                    for match in matches:
                        if pattern_type == 'phone' and len(match.groups()) >= 3:
                            value = f"({match.group(1)}) {match.group(2)}-{match.group(3)}"
                        else:
                            value = match.group(1) if match.groups() else match.group(0)
                        
                        confidence = 0.8
                        if confidence > best_confidence:
                            best_confidence = confidence
                            best_value = value.strip()
            
            if best_value and best_confidence > 0.5:
                extracted_data[field_name] = best_value
                confidence_scores[field_name] = best_confidence
        
        print(f"✅ Pattern extraction found {len(extracted_data)} fields")
        return extracted_data, confidence_scores

class PDFFieldExtractor(QThread):
    """Thread for extracting PDF fields using pdftk"""
    fields_extracted = pyqtSignal(list)
    error_occurred = pyqtSignal(str)
    progress_updated = pyqtSignal(int)

    def __init__(self, pdf_path: str):
        super().__init__()
        self.pdf_path = pdf_path

    def run(self):
        try:
            self.progress_updated.emit(20)
            
            # Check if pdftk is available
            try:
                subprocess.run(['pdftk', '--version'], 
                             capture_output=True, check=True)
            except (subprocess.CalledProcessError, FileNotFoundError):
                self.error_occurred.emit(
                    "pdftk not found. Please install pdftk:\n"
                    "macOS: brew install pdftk-java\n"
                    "Ubuntu: sudo apt install pdftk\n"
                    "Windows: Download from pdftk.org"
                )
                return

            self.progress_updated.emit(50)

            # Extract fields using pdftk
            result = subprocess.run([
                'pdftk', self.pdf_path, 'dump_data_fields'
            ], capture_output=True, text=True, check=True)

            self.progress_updated.emit(80)

            # Parse the output
            fields = self._parse_pdftk_output(result.stdout)
            
            self.progress_updated.emit(100)
            self.fields_extracted.emit(fields)

        except subprocess.CalledProcessError as e:
            self.error_occurred.emit(f"Error extracting fields: {e}")
        except Exception as e:
            self.error_occurred.emit(f"Unexpected error: {str(e)}")

    def _parse_pdftk_output(self, output: str) -> List[FormField]:
        """Parse pdftk dump_data_fields output"""
        fields = []
        current_field = {}
        
        for line in output.strip().split('\n'):
            if line.startswith('---'):
                if current_field:
                    field = FormField(
                        name=current_field.get('FieldName', ''),
                        field_type=current_field.get('FieldType', 'Text'),
                        alt_text=current_field.get('FieldNameAlt', ''),
                        flags=int(current_field.get('FieldFlags', 0)),
                        justification=current_field.get('FieldJustification', 'Left'),
                        state_options=current_field.get('FieldStateOption', [])
                    )
                    fields.append(field)
                current_field = {}
            elif ':' in line:
                key, value = line.split(':', 1)
                key = key.strip()
                value = value.strip()
                
                if key == 'FieldStateOption':
                    if key not in current_field:
                        current_field[key] = []
                    current_field[key].append(value)
                else:
                    current_field[key] = value

        # Add the last field
        if current_field:
            field = FormField(
                name=current_field.get('FieldName', ''),
                field_type=current_field.get('FieldType', 'Text'),
                alt_text=current_field.get('FieldNameAlt', ''),
                flags=int(current_field.get('FieldFlags', 0)),
                justification=current_field.get('FieldJustification', 'Left'),
                state_options=current_field.get('FieldStateOption', [])
            )
            fields.append(field)

        return fields

class PDFFormFiller(QThread):
    """Thread for filling PDF forms"""
    form_filled = pyqtSignal(str)
    error_occurred = pyqtSignal(str)
    progress_updated = pyqtSignal(int)

    def __init__(self, pdf_path: str, field_data: Dict[str, str], output_path: str):
        super().__init__()
        self.pdf_path = pdf_path
        self.field_data = field_data
        self.output_path = output_path

    def run(self):
        try:
            self.progress_updated.emit(20)

            # Create FDF file
            fdf_content = self._create_fdf(self.field_data)
            
            with tempfile.NamedTemporaryFile(mode='w', suffix='.fdf', delete=False) as fdf_file:
                fdf_file.write(fdf_content)
                fdf_path = fdf_file.name

            self.progress_updated.emit(50)

            try:
                # Fill the form using pdftk
                subprocess.run([
                    'pdftk', self.pdf_path, 'fill_form', fdf_path,
                    'output', self.output_path
                ], check=True)

                self.progress_updated.emit(100)
                self.form_filled.emit(self.output_path)

            finally:
                # Clean up temporary FDF file
                os.unlink(fdf_path)

        except Exception as e:
            self.error_occurred.emit(f"Error filling form: {str(e)}")

    def _create_fdf(self, field_data: Dict[str, str]) -> str:
        """Create FDF content for form filling"""
        fdf_header = """%FDF-1.2
1 0 obj
<<
/FDF
<<
/Fields ["""

        fdf_fields = []
        for field_name, field_value in field_data.items():
            if field_value:  # Only include non-empty fields
                escaped_value = field_value.replace('\\', '\\\\').replace('(', '\\(').replace(')', '\\)')
                fdf_fields.append(f"""<<
/T ({field_name})
/V ({escaped_value})
>>""")

        fdf_footer = """]
>>
>>
endobj
trailer

<<
/Root 1 0 R
>>
%%EOF"""

        return fdf_header + '\n' + '\n'.join(fdf_fields) + '\n' + fdf_footer

class MainWindow(QMainWindow):
    """Main application window"""
    
    def __init__(self):
        super().__init__()
        self.current_pdf_path = ""
        self.settings = QSettings("PDFFormFiller", "FormMappings")
        self.form_fields = []
        self.ai_data_sources = []
        self.init_ui()
        self.apply_theme()

    def init_ui(self):
        self.setWindowTitle("PDF Form Filler - Universal Fillable PDF Tool")
        self.setGeometry(100, 100, 1200, 800)

        # Central widget with tabs
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        layout = QVBoxLayout()
        central_widget.setLayout(layout)

        # File selection
        file_layout = QHBoxLayout()
        file_layout.addWidget(QLabel("PDF File:"))
        self.file_path_edit = QLineEdit()
        self.file_path_edit.setReadOnly(True)
        file_layout.addWidget(self.file_path_edit)
        
        self.browse_btn = QPushButton("Browse PDF")
        self.browse_btn.clicked.connect(self.browse_pdf)
        file_layout.addWidget(self.browse_btn)
        
        layout.addLayout(file_layout)

        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        layout.addWidget(self.progress_bar)

        # Tab widget
        self.tab_widget = QTabWidget()
        layout.addWidget(self.tab_widget)

        # Field mapping tab
        self.field_mapping_widget = FieldMappingWidget()
        self.tab_widget.addTab(self.field_mapping_widget, "Field Mapping")

        # AI extraction tab
        self.create_ai_extraction_tab()

        # Data management tab
        self.create_data_management_tab()

        # Action buttons
        button_layout = QHBoxLayout()
        
        self.load_data_btn = QPushButton("Load Mapping")
        self.load_data_btn.clicked.connect(self.load_mapping)
        button_layout.addWidget(self.load_data_btn)
        
        self.save_data_btn = QPushButton("Save Mapping")
        self.save_data_btn.clicked.connect(self.save_mapping)
        button_layout.addWidget(self.save_data_btn)
        
        button_layout.addStretch()
        
        self.fill_form_btn = QPushButton("Fill PDF Form")
        self.fill_form_btn.clicked.connect(self.fill_form)
        self.fill_form_btn.setEnabled(False)
        button_layout.addWidget(self.fill_form_btn)
        
        layout.addLayout(button_layout)

        # Status
        self.status_label = QLabel("Ready - Select a PDF file to begin")
        layout.addWidget(self.status_label)

    def create_ai_extraction_tab(self):
        """Create AI extraction tab with improved error handling"""
        ai_tab = QWidget()
        ai_layout = QVBoxLayout(ai_tab)
        
        # AI Provider Selection
        provider_group = QGroupBox("AI Provider")
        provider_layout = QVBoxLayout()
        
        self.ai_provider_radio_pattern = QRadioButton("Pattern Matching (Free, No API Key Required)")
        self.ai_provider_radio_pattern.setChecked(True)
        provider_layout.addWidget(self.ai_provider_radio_pattern)
        
        self.ai_provider_radio_openai = QRadioButton("OpenAI (API Key Required)")
        provider_layout.addWidget(self.ai_provider_radio_openai)
        
        self.ai_provider_radio_anthropic = QRadioButton("Anthropic Claude (API Key Required)")
        provider_layout.addWidget(self.ai_provider_radio_anthropic)
        
        # Model selection
        model_layout = QHBoxLayout()
        model_layout.addWidget(QLabel("Model:"))
        self.ai_model_combo = QComboBox()
        self.ai_model_combo.addItems(["Default Model"])
        model_layout.addWidget(self.ai_model_combo)
        provider_layout.addLayout(model_layout)
        
        # API Key field
        key_layout = QHBoxLayout()
        key_layout.addWidget(QLabel("API Key:"))
        self.api_key_edit = QLineEdit()
        self.api_key_edit.setEchoMode(QLineEdit.EchoMode.Password)
        self.api_key_edit.setPlaceholderText("Enter API key (only needed for OpenAI/Claude)")
        key_layout.addWidget(self.api_key_edit)
        provider_layout.addLayout(key_layout)
        
        # Connect radio buttons to update model list
        self.ai_provider_radio_pattern.toggled.connect(self._update_ai_model_list)
        self.ai_provider_radio_openai.toggled.connect(self._update_ai_model_list)
        self.ai_provider_radio_anthropic.toggled.connect(self._update_ai_model_list)
        
        provider_group.setLayout(provider_layout)
        ai_layout.addWidget(provider_group)
        
        # Data Sources
        sources_group = QGroupBox("Data Sources")
        sources_layout = QVBoxLayout()
        
        # Source management buttons
        source_buttons = QHBoxLayout()
        
        self.add_file_btn = QPushButton("Add File")
        self.add_file_btn.clicked.connect(self.add_ai_file_source)
        source_buttons.addWidget(self.add_file_btn)
        
        self.add_text_btn = QPushButton("Add Text")
        self.add_text_btn.clicked.connect(self.add_ai_text_source)
        source_buttons.addWidget(self.add_text_btn)
        
        self.add_url_btn = QPushButton("Add URL")
        self.add_url_btn.clicked.connect(self.add_ai_url_source)
        source_buttons.addWidget(self.add_url_btn)
        
        self.add_image_btn = QPushButton("Add Image (OCR)")
        self.add_image_btn.clicked.connect(self.add_ai_image_source)
        source_buttons.addWidget(self.add_image_btn)
        
        source_buttons.addStretch()
        
        self.clear_sources_btn = QPushButton("Clear All")
        self.clear_sources_btn.clicked.connect(self.clear_ai_sources)
        source_buttons.addWidget(self.clear_sources_btn)
        
        sources_layout.addLayout(source_buttons)
        
        # Sources list
        self.sources_list = QListWidget()
        self.sources_list.setMaximumHeight(150)
        sources_layout.addWidget(self.sources_list)
        
        sources_group.setLayout(sources_layout)
        ai_layout.addWidget(sources_group)
        
        # Text Input
        text_group = QGroupBox("Direct Text Input")
        text_layout = QVBoxLayout()
        
        self.ai_text_input = QPlainTextEdit()
        self.ai_text_input.setPlaceholderText(
            "Paste any text here for AI analysis:\n"
            "- Court documents\n"
            "- Case information\n"
            "- Client details\n"
            "- Financial data\n"
            "- Any relevant information"
        )
        self.ai_text_input.setMaximumHeight(150)
        text_layout.addWidget(self.ai_text_input)
        
        text_group.setLayout(text_layout)
        ai_layout.addWidget(text_group)
        
        # Extract Button
        extract_layout = QHBoxLayout()
        
        self.ai_extract_btn = QPushButton("Extract Data")
        self.ai_extract_btn.clicked.connect(self.extract_with_ai)
        extract_layout.addWidget(self.ai_extract_btn)
        
        self.ai_progress = QProgressBar()
        self.ai_progress.setVisible(False)
        extract_layout.addWidget(self.ai_progress)
        
        ai_layout.addLayout(extract_layout)
        
        # Results
        results_group = QGroupBox("Extraction Results")
        results_layout = QVBoxLayout()
        
        self.ai_results = QTextEdit()
        self.ai_results.setReadOnly(True)
        self.ai_results.setPlaceholderText("Results will appear here...")
        results_layout.addWidget(self.ai_results)
        
        results_group.setLayout(results_layout)
        ai_layout.addWidget(results_group)
        
        # Add to tabs
        self.tab_widget.addTab(ai_tab, "AI Data Extraction")

    def create_data_management_tab(self):
        """Create the data management tab"""
        data_widget = QWidget()
        layout = QVBoxLayout()
        
        # Quick data entry
        group = QGroupBox("Quick Data Entry (JSON)")
        group_layout = QVBoxLayout()
        
        self.data_text_edit = QTextEdit()
        self.data_text_edit.setPlaceholderText(
            'Enter field data as JSON:\n'
            '{\n'
            '  "field_name_1": "value1",\n'
            '  "field_name_2": "value2"\n'
            '}'
        )
        group_layout.addWidget(self.data_text_edit)
        
        json_buttons = QHBoxLayout()
        
        apply_json_btn = QPushButton("Apply JSON Data")
        apply_json_btn.clicked.connect(self.apply_json_data)
        json_buttons.addWidget(apply_json_btn)
        
        export_json_btn = QPushButton("Export to JSON")
        export_json_btn.clicked.connect(self.export_to_json)
        json_buttons.addWidget(export_json_btn)
        
        group_layout.addLayout(json_buttons)
        group.setLayout(group_layout)
        layout.addWidget(group)
        
        data_widget.setLayout(layout)
        self.tab_widget.addTab(data_widget, "Data Management")

    def apply_theme(self):
        """Apply a modern theme to the application"""
        self.setStyleSheet("""
            QMainWindow {
                background-color: #f5f5f5;
            }
            QPushButton {
                background-color: #2196F3;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1976D2;
            }
            QPushButton:disabled {
                background-color: #cccccc;
            }
            QGroupBox {
                font-weight: bold;
                border: 2px solid #cccccc;
                border-radius: 5px;
                margin: 10px 0px;
                padding-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }
            QLineEdit {
                border: 1px solid #ddd;
                border-radius: 4px;
                padding: 6px;
            }
            QLineEdit:focus {
                border-color: #2196F3;
            }
            QTabWidget::pane {
                border: 1px solid #cccccc;
            }
            QTabBar::tab {
                background-color: #e0e0e0;
                padding: 8px 16px;
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: #2196F3;
                color: white;
            }
        """)

    def browse_pdf(self):
        """Browse for PDF file"""
        print("DEBUG: Browse PDF button clicked")
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Select PDF File", "", "PDF Files (*.pdf)"
        )
        
        if file_path:
            print(f"DEBUG: Selected PDF: {file_path}")
            self.current_pdf_path = file_path
            self.file_path_edit.setText(file_path)
            self.extract_fields()
        else:
            print("DEBUG: No PDF file selected")

    def extract_fields(self):
        """Extract fields from the selected PDF"""
        if not self.current_pdf_path:
            return

        self.progress_bar.setVisible(True)
        self.progress_bar.setValue(0)
        self.status_label.setText("Extracting form fields...")
        
        self.extractor_thread = PDFFieldExtractor(self.current_pdf_path)
        self.extractor_thread.fields_extracted.connect(self.on_fields_extracted)
        self.extractor_thread.error_occurred.connect(self.on_extraction_error)
        self.extractor_thread.progress_updated.connect(self.progress_bar.setValue)
        self.extractor_thread.start()

    def on_fields_extracted(self, fields: List[FormField]):
        """Handle successful field extraction"""
        self.progress_bar.setVisible(False)
        self.field_mapping_widget.set_fields(fields)
        self.form_fields = fields
        self.fill_form_btn.setEnabled(True)
        self.status_label.setText(f"Ready - Found {len(fields)} form fields")

    def on_extraction_error(self, error_message: str):
        """Handle field extraction error"""
        self.progress_bar.setVisible(False)
        self.status_label.setText("Error extracting fields")
        QMessageBox.critical(self, "Error", error_message)

    # AI Data Source Management Methods
    def add_ai_file_source(self):
        """Add a file as data source for AI analysis"""
        try:
            file_path, _ = QFileDialog.getOpenFileName(
                self, "Select Data File", "",
                "All Supported (*.pdf *.txt *.json *.csv *.md);;PDF Files (*.pdf);;Text Files (*.txt);;JSON Files (*.json);;CSV Files (*.csv)"
            )
            
            if file_path:
                file_name = os.path.basename(file_path)
                self.sources_list.addItem(f"File: {file_name}")
                self.ai_data_sources.append(('file', str(file_path)))
                print(f"Added file source: {file_name}")
                
        except Exception as e:
            print(f"Error adding file source: {e}")
            QMessageBox.warning(self, "Error", f"Error adding file: {str(e)}")
    
    def add_ai_text_source(self):
        """Add text input as data source for AI analysis"""
        try:
            text = self.ai_text_input.toPlainText().strip()
            if text:
                self.sources_list.addItem(f"Text: {len(text)} chars")
                
                # Truncate very long text to avoid memory issues
                max_len = 5000
                if len(text) > max_len:
                    truncated = text[:max_len] + "... (truncated)"
                    self.ai_data_sources.append(('text', truncated))
                else:
                    self.ai_data_sources.append(('text', text))
                    
                self.ai_text_input.clear()
                print("Added text source")
        except Exception as e:
            print(f"Error adding text source: {e}")
    
    def add_ai_url_source(self):
        """Add URL as data source for AI analysis"""
        try:
            url, ok = QInputDialog.getText(
                self, "Add URL Source",
                "Enter URL to scrape for data:",
                QLineEdit.EchoMode.Normal,
                "https://"
            )
            
            if ok and url:
                display_url = url[:50] + "..." if len(url) > 50 else url
                self.sources_list.addItem(f"URL: {display_url}")
                self.ai_data_sources.append(('url', url))
                print(f"Added URL source: {url}")
        except Exception as e:
            print(f"Error adding URL source: {e}")
    
    def add_ai_image_source(self):
        """Add image for OCR as data source for AI analysis"""
        try:
            if not OCR_AVAILABLE:
                QMessageBox.warning(
                    self, "OCR Not Available",
                    "OCR functionality requires pytesseract and Pillow.\n"
                    "Install with: pip install pytesseract Pillow"
                )
                return
            
            file_path, _ = QFileDialog.getOpenFileName(
                self, "Select Image File", "",
                "Image Files (*.png *.jpg *.jpeg *.tiff *.bmp *.gif)"
            )
            
            if file_path:
                file_name = os.path.basename(file_path)
                self.sources_list.addItem(f"Image: {file_name}")
                self.ai_data_sources.append(('image', str(file_path)))
                print(f"Added image source: {file_name}")
        except Exception as e:
            print(f"Error adding image source: {e}")

    def clear_ai_sources(self):
        """Clear all AI data sources"""
        try:
            self.sources_list.clear()
            self.ai_data_sources = []
            print("AI sources cleared")
        except Exception as e:
            print(f"Error clearing sources: {e}")

    def _update_ai_model_list(self):
        """Update the model list based on selected provider"""
        try:
            self.ai_model_combo.clear()
            
            if self.ai_provider_radio_openai.isChecked():
                openai_models = [
                    "gpt-4o",
                    "gpt-4-turbo",
                    "gpt-4",
                    "gpt-3.5-turbo"
                ]
                self.ai_model_combo.addItems(openai_models)
                
            elif self.ai_provider_radio_anthropic.isChecked():
                claude_models = [
                    "claude-3-5-sonnet-20240620",
                    "claude-3-opus-20240229",
                    "claude-3-sonnet-20240229",
                    "claude-3-haiku-20240307"
                ]
                self.ai_model_combo.addItems(claude_models)
                
            else:
                # Pattern matching has no model selection
                self.ai_model_combo.addItem("Pattern Matching (No Model)")
                
        except Exception as e:
            print(f"Error updating model list: {e}")

    def extract_with_ai(self):
        """Extract data using AI with improved error handling"""
        try:
            # Check if form fields are available
            if not self.form_fields:
                QMessageBox.warning(self, "No Form Fields",
                                   "Please load a PDF form first to define extraction fields.")
                return
                
            # Check if we have any data sources
            has_text = bool(self.ai_text_input.toPlainText().strip())
            has_sources = bool(self.ai_data_sources)
            
            if not has_text and not has_sources:
                QMessageBox.warning(self, "No Input",
                                   "Please enter some text or add data sources to analyze.")
                return
                
            # Determine AI provider
            if self.ai_provider_radio_openai.isChecked():
                provider = "openai"
                if not self.api_key_edit.text().strip():
                    QMessageBox.warning(self, "API Key Required",
                                      "Please enter an OpenAI API key.")
                    return
            elif self.ai_provider_radio_anthropic.isChecked():
                provider = "anthropic"
                if not self.api_key_edit.text().strip():
                    QMessageBox.warning(self, "API Key Required",
                                      "Please enter an Anthropic API key.")
                    return
            else:
                provider = "pattern"
                
            # Show progress
            self.ai_progress.setVisible(True)
            self.ai_progress.setValue(10)
            self.ai_extract_btn.setEnabled(False)
            self.status_label.setText("Extracting data...")
            
            # Create data sources
            sources = []
            
            # Add text input as source
            if has_text:
                text_content = self.ai_text_input.toPlainText().strip()
                sources.append(DataSource("Direct Text Input", "text", text_content))
            
            # Add file/URL/image sources
            for source_type, source_content in self.ai_data_sources:
                source_name = f"{source_type.title()}: {os.path.basename(source_content) if source_type == 'file' else source_content[:50]}"
                sources.append(DataSource(source_name, source_type, source_content))
            
            # Get selected model
            selected_model = self.ai_model_combo.currentText()
            api_key = self.api_key_edit.text().strip()
            
            # Start extraction thread
            self.extractor_thread = AIDataExtractor(
                sources, self.form_fields, provider, api_key, selected_model
            )
            self.extractor_thread.data_extracted.connect(self.on_ai_data_extracted)
            self.extractor_thread.error_occurred.connect(self.on_ai_extraction_error)
            self.extractor_thread.progress_updated.connect(self.on_ai_progress_updated)
            self.extractor_thread.show_message.connect(self.show_ai_message)
            self.extractor_thread.start()
            
        except Exception as e:
            print(f"Error in extract_with_ai: {e}")
            QMessageBox.critical(self, "Error", f"Error during AI extraction: {str(e)}")
            self.ai_progress.setVisible(False)
            self.ai_extract_btn.setEnabled(True)

    def on_ai_data_extracted(self, extracted_data: dict, confidence_scores: dict):
        """Handle successful AI data extraction"""
        try:
            # Apply to form fields
            self.field_mapping_widget.set_field_data(extracted_data)
            
            # Show results
            result_text = "Extraction Results:\n\n"
            for field_name, value in extracted_data.items():
                conf = confidence_scores.get(field_name, 0.0)
                result_text += f"• {field_name}: {value} (confidence: {conf:.1%})\n"
                
            self.ai_results.setPlainText(result_text)
            self.status_label.setText(f"Extracted {len(extracted_data)} field values")
            
        except Exception as e:
            print(f"Error processing AI results: {e}")
        finally:
            self.ai_progress.setVisible(False)
            self.ai_extract_btn.setEnabled(True)

    def on_ai_extraction_error(self, error_message: str):
        """Handle AI extraction error"""
        self.ai_results.setPlainText(f"Error during extraction: {error_message}")
        self.ai_progress.setVisible(False)
        self.ai_extract_btn.setEnabled(True)
        self.status_label.setText("AI extraction failed")

    def on_ai_progress_updated(self, progress: int, message: str):
        """Handle AI extraction progress updates"""
        self.ai_progress.setValue(progress)
        self.status_label.setText(message)

    def show_ai_message(self, title: str, message: str):
        """Show AI message in a thread-safe way"""
        QMessageBox.information(self, title, message)

    # Data Management Methods
    def apply_json_data(self):
        """Apply JSON data to form fields"""
        try:
            json_text = self.data_text_edit.toPlainText()
            if not json_text.strip():
                return
                
            data = json.loads(json_text)
            self.field_mapping_widget.set_field_data(data)
            self.status_label.setText("JSON data applied successfully")
            
        except json.JSONDecodeError as e:
            QMessageBox.warning(self, "Invalid JSON", f"JSON parsing error: {str(e)}")

    def export_to_json(self):
        """Export current field data to JSON"""
        data = self.field_mapping_widget.get_field_data()
        # Filter out empty fields
        filtered_data = {k: v for k, v in data.items() if v.strip()}
        
        json_text = json.dumps(filtered_data, indent=2)
        self.data_text_edit.setPlainText(json_text)

    def save_mapping(self):
        """Save current field mapping"""
        if not self.current_pdf_path:
            QMessageBox.warning(self, "No PDF", "Please select a PDF file first")
            return

        file_path, _ = QFileDialog.getSaveFileName(
            self, "Save Field Mapping", "", "JSON Files (*.json)"
        )
        
        if file_path:
            data = self.field_mapping_widget.get_field_data()
            try:
                with open(file_path, 'w') as f:
                    json.dump(data, f, indent=2)
                self.status_label.setText(f"Mapping saved to {file_path}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to save mapping: {str(e)}")

    def load_mapping(self):
        """Load field mapping from file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Load Field Mapping", "", "JSON Files (*.json)"
        )
        
        if file_path:
            try:
                with open(file_path, 'r') as f:
                    data = json.load(f)
                self.field_mapping_widget.set_field_data(data)
                self.status_label.setText(f"Mapping loaded from {file_path}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to load mapping: {str(e)}")

    def fill_form(self):
        """Fill the PDF form with current data"""
        if not self.current_pdf_path:
            QMessageBox.warning(self, "No PDF", "Please select a PDF file first")
            return

        field_data = self.field_mapping_widget.get_field_data()
        # Filter out empty fields
        field_data = {k: v for k, v in field_data.items() if v.strip()}
        
        if not field_data:
            QMessageBox.warning(self, "No Data", "Please enter some field data first")
            return

        output_path, _ = QFileDialog.getSaveFileName(
            self, "Save Filled PDF", "", "PDF Files (*.pdf)"
        )
        
        if output_path:
            self.progress_bar.setVisible(True)
            self.progress_bar.setValue(0)
            self.status_label.setText("Filling PDF form...")
            
            self.filler_thread = PDFFormFiller(
                self.current_pdf_path, field_data, output_path
            )
            self.filler_thread.form_filled.connect(self.on_form_filled)
            self.filler_thread.error_occurred.connect(self.on_fill_error)
            self.filler_thread.progress_updated.connect(self.progress_bar.setValue)
            self.filler_thread.start()

    def on_form_filled(self, output_path: str):
        """Handle successful form filling"""
        self.progress_bar.setVisible(False)
        self.status_label.setText(f"Form filled successfully: {output_path}")
        
        reply = QMessageBox.question(
            self, "Success", 
            f"PDF form filled successfully!\n\nSaved to: {output_path}\n\nOpen the file?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            os.system(f'open "{output_path}"' if sys.platform == 'darwin' else f'start "{output_path}"')

    def on_fill_error(self, error_message: str):
        """Handle form filling error"""
        self.progress_bar.setVisible(False)
        self.status_label.setText("Error filling form")
        QMessageBox.critical(self, "Error", error_message)

def main():
    """Main entry point for PDF Form Filler v3"""
    app = QApplication(sys.argv)
    app.setApplicationName("PDF Form Filler")
    app.setApplicationVersion("3.0")
    
    # Set application icon if available
    try:
        app.setWindowIcon(QIcon("icon.png"))
    except:
        pass
    
    window = MainWindow()
    window.show()
    
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
